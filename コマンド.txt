#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <arpa/inet.h>
#include <pigpio.h>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/imgproc.hpp>
#include <vector>
#include <thread>

using namespace std;
using namespace cv;

// 設定
char pc_ip[] = "192.168.0.227";
int ras_recv_port = 9001;
int port_pc_cam1 = 8081;
int port_pc_cam2 = 8082;
int baudRate = 9600;
int fps = 20;
int msgNum = 2;

void thread_cv(int port, int WIDTH, int HEIGHT, int num, int ratio);

int main() {
    // UDPソケット作成
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        cerr << "[UDP]Socket creation failed" << endl;
        return -1;
    }

    // UDP受信バッファ拡大（例：256KB）
    int bufsize = 256 * 1024;
    setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &bufsize, sizeof(bufsize));

    // ソケットアドレス設定
    sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(ras_recv_port);

    if (bind(sock, (sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        cerr << "[UDP]Bind failed" << endl;
        close(sock);
        return -1;
    }

    // 非ブロッキングモード設定
    int flags = fcntl(sock, F_GETFL, 0);
    fcntl(sock, F_SETFL, flags | O_NONBLOCK);

    // pigpio初期化
    if (gpioInitialise() < 0) {
        cerr << "[UART]pigpio initialization failed!" << endl;
        return 1;
    }

    // UART初期化
    int serialHandle = serOpen(const_cast<char*>("/dev/serial0"), baudRate, 0);
    if (serialHandle < 0) {
        cerr << "[UART]Failed to open serial port!" << endl;
        gpioTerminate();
        return 1;
    }
    cout << "[UART] initialized at baud rate " << baudRate << endl;

    fd_set readfds;
    sockaddr_in clientAddr{};
    socklen_t addrLen = sizeof(clientAddr);
    char buffer[16];

    cout << "[UDP]Listening for UDP packets..." << endl;

    while (true) {
        FD_ZERO(&readfds);
        FD_SET(sock, &readfds);

        // タイムアウトを短く（100ms）
        timeval timeout{};
        timeout.tv_sec = 0;
        timeout.tv_usec = 100000;

        int activity = select(sock + 1, &readfds, nullptr, nullptr, &timeout);
        if (activity < 0) {
            cerr << "select() error" << endl;
            break;
        }

        if (activity == 0) {
            // タイムアウト（デフォルトコマンド送信）
            char dami_buffer[msgNum] = { 'k', 0 };
            int result = serWrite(serialHandle, dami_buffer, msgNum);
            if (result < 0) {
                cerr << "[UART]Failed to send data!" << endl;
            } else {
                printf("Time Out! \ndami_buff[0]: %c , %u  dami_buff[1]: %c , %u\n",
                       dami_buffer[0], dami_buffer[0], dami_buffer[1], dami_buffer[1]);
            }
            continue;
        }

        if (FD_ISSET(sock, &readfds)) {
            // UDPパケットが溜まっている限り、受信し続ける
            while (true) {
                ssize_t len = recvfrom(sock, buffer, sizeof(buffer) - 1, 0, (sockaddr*)&clientAddr, &addrLen);
                if (len <= 0) break;

                buffer[len] = '\0';
                cout << "[UDP]Received: " << buffer << endl;

                int result = serWrite(serialHandle, buffer, msgNum);
                if (result < 0) {
                    cerr << "[UART]Failed to send data!" << endl;
                } else {
                    printf("uart送信数:%d\n buffer[0]: %c , %u  buffer[1]: %c , %u\n",
                           msgNum, buffer[0], buffer[0], buffer[1], buffer[1]);
                }
            }
        }
    }

    serClose(serialHandle);
    gpioTerminate();
    close(sock);
    return 0;
}

// カメラ送信用スレッド
void thread_cv(int port, int WIDTH, int HEIGHT, int num, int ratio) {
    int sock;
    struct sockaddr_in addr;
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(pc_ip);

    VideoCapture cap(num);
    cap.set(CAP_PROP_FRAME_WIDTH, WIDTH);
    cap.set(CAP_PROP_FRAME_HEIGHT, HEIGHT);
    cap.set(CAP_PROP_FPS, fps);

    if (!cap.isOpened()) {
        cout << "Camera not Found\n!" << endl;
        return;
    }

    Mat frame, jpgimg;
    static const int sendSize = 65500;
    char buff[sendSize];
    vector<unsigned char> ibuff;
    vector<int> param = {IMWRITE_JPEG_QUALITY, ratio};

    while (waitKey(1) == -1) {
        cap >> frame;
        imencode(".jpg", frame, ibuff, param);

        if (ibuff.size() < sendSize) {
            copy(ibuff.begin(), ibuff.end(), buff);
            sendto(sock, buff, sendSize, 0, (struct sockaddr*)&addr, sizeof(addr));
            jpgimg = imdecode(Mat(ibuff), IMREAD_COLOR);
        }

        this_thread::sleep_for(chrono::milliseconds(1000 / fps));
    }

    close(sock);
}
