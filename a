#include <iostream>
#include <cstring>
#include <vector>
#include <thread>
#include <chrono>

// --- 通信関連 ---
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h> // write, read, close, usleep
#include <fcntl.h>  // fcntl, O_RDWR, O_NOCTTY, O_NONBLOCK

// --- シリアル通信関連 (termios) ---
#include <termios.h>

// --- OpenCV関連 ---
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/imgproc.hpp>

using namespace std;
using namespace cv;

// --- 設定 ---
const char PC_IP[] = "192.168.23.5";
const int RAS_RECV_PORT = 9001;
const int PORT_PC_CAM1 = 8081;
const int BAUD_RATE = B9600; // termios.hで定義されている定数を使用
const int FPS = 20;

// --- プロトタイプ宣言 ---
void thread_cv(int port, int width, int height, int device_num, int quality_ratio);
int setup_serial_port(const char* port_name, speed_t baud_rate);

// =================================================================
//  メインスレッド: UDP受信 と UART送信 に特化
// =================================================================
int main() {
    // --- カメラ用スレッドを開始 ---
    thread th1(thread_cv, PORT_PC_CAM1, 1920 / 3, 1080 / 3, 0, 50);
    th1.detach();

    // --- UARTポートをセットアップ ---
    int serial_fd = setup_serial_port("/dev/serial0", BAUD_RATE);
    if (serial_fd < 0) {
        return 1;
    }
    cout << "[UART] Serial port opened successfully." << endl;

    // --- UDPソケットをセットアップ ---
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        cerr << "[UDP] Socket creation failed" << endl;
        return -1;
    }

    sockaddr_in serverAddr{};
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = INADDR_ANY;
    serverAddr.sin_port = htons(RAS_RECV_PORT);

    if (bind(sock, (sockaddr*)&serverAddr, sizeof(serverAddr)) < 0) {
        cerr << "[UDP] Bind failed" << endl;
        close(sock);
        return -1;
    }

    // ソケットを非ブロッキングモードに設定
    fcntl(sock, F_SETFL, O_NONBLOCK);

    cout << "[UDP] Listening on port " << RAS_RECV_PORT << endl;

    // --- メインループ ---
    char buffer[16];
    const int MSG_NUM = 2;

    while (true) {
        // UDPソケットからデータをノンブロッキングで受信試行
        ssize_t len = recvfrom(sock, buffer, sizeof(buffer) - 1, 0, nullptr, nullptr);

        if (len > 0) {
            // データを受信した場合、UARTに送信
            buffer[len] = '\0';
            cout << "[UDP] Received: " << buffer << endl;
            
            // UARTポートに書き込む
            ssize_t written = write(serial_fd, buffer, MSG_NUM);
            if (written < 0) {
                cerr << "[UART] Failed to write to serial port!" << endl;
            }
        }
        
        // CPUを100%消費しないように、非常に短い待機を入れる
        usleep(1000); // 1ms待機
    }

    close(serial_fd);
    close(sock);
    return 0;
}

// =================================================================
//  カメラ処理スレッド: 変更なし
// =================================================================
void thread_cv(int port, int width, int height, int device_num, int quality_ratio) {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) {
        cerr << "[CAM_THREAD] Socket creation failed" << endl;
        return;
    }

    sockaddr_in addr{};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr.s_addr = inet_addr(PC_IP);

    VideoCapture cap(device_num);
    cap.set(CAP_PROP_FRAME_WIDTH, width);
    cap.set(CAP_PROP_FRAME_HEIGHT, height);
    cap.set(CAP_PROP_FPS, FPS);

    if (!cap.isOpened()) {
        cout << "[CAM_THREAD] Camera not found! Device: " << device_num << endl;
        return;
    }

    Mat frame;
    vector<unsigned char> ibuff;
    vector<int> param = { IMWRITE_JPEG_QUALITY, quality_ratio };

    while (true) {
        cap >> frame;
        if (frame.empty()) {
            cerr << "[CAM_THREAD] Failed to capture frame" << endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(500));
            continue;
        }

        imencode(".jpg", frame, ibuff, param);

        if (!ibuff.empty()) {
            sendto(sock, ibuff.data(), ibuff.size(), 0, (struct sockaddr*)&addr, sizeof(addr));
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(1000 / FPS));
    }
    close(sock);
}


// =================================================================
//  標準APIによるシリアルポート設定関数
// =================================================================
int setup_serial_port(const char* port_name, speed_t baud_rate) {
    int fd = open(port_name, O_RDWR | O_NOCTTY);
    if (fd < 0) {
        cerr << "[UART] Error opening " << port_name << ": " << strerror(errno) << endl;
        return -1;
    }

    termios tty{};
    if (tcgetattr(fd, &tty) != 0) {
        cerr << "[UART] Error from tcgetattr: " << strerror(errno) << endl;
        close(fd);
        return -1;
    }

    // ボーレート設定
    cfsetospeed(&tty, baud_rate);
    cfsetispeed(&tty, baud_rate);

    // 制御フラグ設定
    tty.c_cflag &= ~PARENB;  // パリティなし
    tty.c_cflag &= ~CSTOPB;  // ストップビット1
    tty.c_cflag &= ~CSIZE;   // データビット長クリア
    tty.c_cflag |= CS8;      // 8データビット
    tty.c_cflag &= ~CRTSCTS; // ハードウェアフロー制御なし
    tty.c_cflag |= CREAD | CLOCAL; // 受信有効、モデム制御線無視

    // ローカルフラグ設定 (Non-Canonical Mode)
    tty.c_lflag &= ~ICANON;
    tty.c_lflag &= ~ECHO;
    tty.c_lflag &= ~ECHOE;
    tty.c_lflag &= ~ECHONL;
    tty.c_lflag &= ~ISIG;

    // 入力フラグ設定
    tty.c_iflag &= ~(IXON | IXOFF | IXANY);
    tty.c_iflag &= ~(IGNBRK | BRKINT | PARMRK | ISTRIP | INLCR | IGNCR | ICRNL);

    // 出力フラグ設定
    tty.c_oflag &= ~OPOST;
    tty.c_oflag &= ~ONLCR;

    // 読み取りタイムアウト設定 (ここでは使わない)
    tty.c_cc[VMIN] = 0;
    tty.c_cc[VTIME] = 0;

    // 設定を適用
    if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        cerr << "[UART] Error from tcsetattr: " << strerror(errno) << endl;
        close(fd);
        return -1;
    }

    return fd;
}
